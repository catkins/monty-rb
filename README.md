# Monty Ruby

Ruby bindings for [Monty](https://github.com/pydantic/monty), a minimal and secure Python interpreter written in Rust. Built with [Magnus](https://github.com/matsadler/magnus).

Monty is designed for AI agents â€” it safely executes Python code generated by LLMs with sub-microsecond startup, strict sandboxing, and no filesystem or network access.

## Installation

Add to your Gemfile:

```ruby
gem "monty"
```

Or install directly:

```sh
gem install monty
```

Requires Rust 1.90+ for compilation.

## Usage

### Simple Execution

```ruby
require "monty"

# Evaluate a Python expression
run = Monty::Run.new("x + y", inputs: ["x", "y"])
run.call(1, 2) # => 3

# Python functions
code = <<~PYTHON
  def factorial(n):
      if n <= 1:
          return 1
      return n * factorial(n - 1)

  factorial(n)
PYTHON

run = Monty::Run.new(code, inputs: ["n"])
run.call(10) # => 3628800
```

### Data Type Conversion

Ruby values are automatically converted to Python and back:

| Ruby | Python | Ruby |
|------|--------|------|
| `nil` | `None` | `nil` |
| `true` / `false` | `True` / `False` | `true` / `false` |
| `Integer` | `int` | `Integer` |
| `Float` | `float` | `Float` |
| `String` | `str` | `String` |
| `Array` | `list` | `Array` |
| `Hash` | `dict` | `Hash` |
| `Symbol` | `str` | `String` |

### Capturing Output

```ruby
run = Monty::Run.new("print('hello')\n42")
result = run.call(capture_output: true)
result[:result] # => 42
result[:output] # => "hello\n"
```

### Resource Limits

```ruby
run = Monty::Run.new("x ** x ** x", inputs: ["x"])
run.call(100, limits: {
  max_duration: 2.0,        # seconds
  max_memory: 10_485_760,   # bytes
  max_allocations: 100_000,
  max_recursion_depth: 500
})
```

### External Function Calls

Monty scripts can call external functions that you implement in Ruby:

```ruby
code = <<~PYTHON
  response = fetch("https://api.example.com/data")
  response.upper()
PYTHON

run = Monty::Run.new(code, external_functions: ["fetch"])

# Block-based API (recommended)
result = run.call_with_externals do |call|
  case call.function_name
  when "fetch"
    Net::HTTP.get(URI(call.args[0]))
  end
end

# Manual step-through API
run = Monty::Run.new(code, external_functions: ["fetch"])
progress = run.start

while progress.is_a?(Monty::FunctionCall)
  result = handle_function(progress.function_name, progress.args)
  progress = progress.resume(result)
end

final_value = progress.value
```

### Serialization

Monty::Run instances can be serialized for caching or storage:

```ruby
run = Monty::Run.new("x * 2", inputs: ["x"])
bytes = run.dump

# Later...
restored = Monty::Run.load(bytes)
restored.call(21) # => 42
```

## Error Handling

```ruby
# Monty::Error        - base error class
# Monty::SyntaxError  - Python syntax errors
# Monty::ResourceError - resource limit exceeded
# Monty::ConsumedError - using a consumed Run/FunctionCall

begin
  run = Monty::Run.new("1 / 0")
  run.call
rescue Monty::Error => e
  puts e.message
end
```

## Development

```sh
bundle install
bundle exec rake compile  # build native extension
bundle exec rake spec     # run tests
bundle exec rake          # compile + test
```

## License

MIT
